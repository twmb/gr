package g

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
)

var (
	goroPfx        = []byte("goroutine ")
	lockedToThread = []byte(", locked to thread")
	scanPfx        = []byte(", (scan)")
	minutesSfx     = []byte(" minutes")

	additionalFramesElided = []byte("...additional frames elided...")
	goroUnavailable        = []byte("goroutine running on other thread; stack unavailable")
	createdByPfx           = []byte("created by ")

	autogenerated = []byte("<autogenerated>")

	// the following maps memoize strings
	calls      = make(map[string]string, 1000)
	files      = make(map[string]string, 100)
	statuses   = make(map[string]string, 50)
	createdBys = make(map[string]string, 200)
)

func strmap(m map[string]string, in []byte) string {
	s, ok := m[string(in)]
	if !ok {
		s = string(in)
		m[s] = s
	}
	return s
}

func parseInt(b []byte) int {
	var i int
	for _, c := range b {
		i = 10*i + int(c-'0')
	}
	return i
}

func isInt(b []byte) bool {
	for _, c := range b {
		if c < '0' || c > '9' {
			return false
		}
	}
	return true
}

func parseNewG(in []byte) (id int, status []byte, minutes int, locked, ok bool) {
	if !bytes.HasPrefix(in, goroPfx) {
		return 0, nil, 0, false, false
	}
	in = in[len(goroPfx):]

	idEnd := bytes.IndexByte(in, ' ')
	if idEnd < 1 {
		return 0, nil, 0, false, false
	}

	idRaw := in[:idEnd]
	in = in[idEnd+1:]
	if !isInt(idRaw) {
		return 0, nil, 0, false, false
	}
	id = parseInt(idRaw)

	l := len(in)
	if l < 4 || in[0] != '[' || in[l-1] != ':' || in[l-2] != ']' {
		return 0, nil, 0, false, false
	}
	in = in[1 : l-2]

	statusEnd := bytes.IndexByte(in, ',')
	if statusEnd < 1 {
		status = in
		return id, status, 0, false, true
	}
	status = in[:statusEnd]
	in = in[statusEnd:]

	if bytes.HasPrefix(in, scanPfx) {
		in = in[len(scanPfx):]
	}

	if bytes.HasSuffix(in, lockedToThread) {
		in = in[:len(in)-len(lockedToThread)]
		locked = true
	}

	if len(in) != 0 {
		if len(in) < 3 ||
			in[0] != ',' ||
			in[1] != ' ' ||
			!bytes.HasSuffix(in, minutesSfx) ||
			!isInt(in[2:len(in)-len(minutesSfx)]) {
			return 0, nil, 0, false, false
		}
		minutes = parseInt(in[2 : len(in)-len(minutesSfx)])
	}
	return id, status, minutes, locked, true
}

func parseCall(in []byte) (call, args []byte, elided, inline, ok bool) {
	lParen := bytes.LastIndexByte(in, '(')
	if lParen == -1 {
		return nil, nil, false, false, false
	}
	call = in[:lParen]
	in = in[lParen+1:]
	rParen := bytes.IndexByte(in, ')')
	if rParen == -1 || rParen != len(in)-1 {
		return nil, nil, false, false, false
	}

	in = in[:rParen]
	l := len(in)
	if l == 0 { // args are optional
		return call, nil, false, false, true
	}
	if l == 3 && in[0] == '.' && in[1] == '.' && in[2] == '.' { // inline is just "..."
		return call, nil, false, true, true
	}
	if l > 5 && // elided is ", ..."
		in[l-1] == '.' &&
		in[l-2] == '.' &&
		in[l-3] == '.' &&
		in[l-4] == ' ' &&
		in[l-5] == ',' {
		elided = true
		in = in[:l-5]
	}
	args = in
	return call, args, elided, false, true
}

func parseFile(in []byte) (file []byte, line int, autogen []byte, ok bool) {
	if bytes.Equal(in, autogenerated) {
		return nil, 0, autogenerated, true
	}

	if in[0] == '\t' {
		in = in[1:]
	} else {
		i := 0
		for ; i < len(in) && in[i] == ' '; i++ {
		}
		in = in[i:]
	}

	colon := bytes.IndexByte(in, ':')
	if colon == -1 {
		return nil, 0, nil, false
	}
	file = in[:colon]
	if len(file) == 0 {
		return nil, 0, nil, false
	}

	in = in[colon+1:]
	endLineNum := 0
	var c byte
	for endLineNum, c = range in {
		if c < '0' || c > '9' {
			break
		}
		endLineNum++
	}
	lineRaw := in[:endLineNum]

	if len(lineRaw) == 0 {
		return nil, 0, nil, false
	}

	return file, parseInt(lineRaw), nil, true
}

type parser struct {
	g *goroutine

	next func(*parser, []byte)

	corrupt      bool
	corruptFatal bool
}

type ParseOpt func(*parser) error

func ParseCorruptFatally(p *parser) error {
	p.corruptFatal = true
	return nil
}

func Parse(r io.Reader, opts ...ParseOpt) (*Dump, error) {
	p := new(parser)
	for _, opt := range opts {
		if err := opt(p); err != nil {
			return nil, err
		}
	}

	scanner := bufio.NewScanner(r)

	gs := make([]*goroutine, 0, 10000)
	for scanner.Scan() {
		line := scanner.Bytes()
		if g := p.parse(line); g != nil {
			gs = append(gs, g)
		}
	}

	if len(gs) == 0 {
		return nil, errors.New("no found goroutines")
	}

	return &Dump{gs: gs}, nil
}

func (p *parser) parse(line []byte) *goroutine {
	switch {
	case len(line) == 0:
		// return g below

	case p.corrupt:
		return nil

	case p.g == nil: // new goroutine
		id, status, minutes, locked, ok := parseNewG(line)
		if !ok {
			p.setCorrupt("failed looking for new goroutine", line)
			return nil
		}

		p.g = &goroutine{
			id:      id,
			status:  strmap(statuses, status),
			minutes: minutes,
			locked:  locked,
		}
		p.next = stateFirstCall

		return nil

	default:
		p.next(p, line)
		if p.corrupt || p.next != nil {
			return nil
		}
		// return g below
	}

	g := p.g
	p.g = nil
	p.corrupt = false
	return g
}

func (p *parser) lastFrame() *frame {
	return &p.g.stack[len(p.g.stack)-1]
}

func stateFirstCall(p *parser, line []byte) {
	call, args, elided, inline, ok := parseCall(line)
	if !ok {
		p.setCorrupt("failed looking for first function call", line)
		return
	}
	stateParseCall(p, call, args, elided, inline)
	p.next = stateUnavailOrFile
}

func stateParseCall(p *parser, rawCall, args []byte, elided, inline bool) {
	f := frame{
		call: call{
			name: strmap(calls, rawCall),
		},
		argsElided: elided,
		inlFunc:    inline,
	}

	if !f.inlFunc && len(args) > 0 {
		ncommas := bytes.Count(args, []byte{','})
		f.args = make([]int, 0, ncommas+1)
		for ncommas > 0 {
			comma := bytes.IndexByte(args, ',')
			f.args = append(f.args, parseInt(args[:comma]))
			args = args[comma+1:]
			ncommas--
		}
		f.args = append(f.args, parseInt(args))
	}

	if len(p.g.stack) == 0 {
		p.g.stack = make([]frame, 0, 6)
	}
	p.g.stack = append(p.g.stack, f)
}

func stateUnavailOrFile(p *parser, line []byte) {
	// TODO cgo here

	if bytes.HasSuffix(line, goroUnavailable) {
		p.lastFrame().unavailable = true
		p.next = stateCreatedByStart
		return
	}
	stateFile(p, line)
}

func stateFile(p *parser, line []byte) {
	file, lineNum, autogen, ok := parseFile(line)
	if !ok {
		p.setCorrupt("failed looking for file", line)
		return
	}

	f := p.lastFrame()
	if len(autogen) > 0 {
		f.call.file = "<autogenerated>"

	} else {
		f.call.file = strmap(files, file)
		f.call.line = lineNum
	}

	p.next = stateCallOrEnd
}

func stateCallOrEnd(p *parser, line []byte) {
	if bytes.Equal(line, additionalFramesElided) {
		p.g.framesElided = true
		p.next = stateCreatedByStart
		return
	}

	if bytes.HasPrefix(line, createdByPfx) {
		p.g.createdBy.name = strmap(createdBys, line[len(createdByPfx):])
		p.next = stateCreatedByEnd
		return
	}

	call, args, elided, inline, ok := parseCall(line)
	if !ok {
		p.setCorrupt("failed looking for function call", line)
	}
	stateParseCall(p, call, args, elided, inline)
	p.next = stateFile
}

func stateCreatedByStart(p *parser, line []byte) { // XXX maybe optional?
	if !bytes.HasPrefix(line, createdByPfx) {
		p.setCorrupt("failed looking for created by", line)
		return
	}
	p.g.createdBy.name = strmap(createdBys, line[len(createdByPfx):])
	p.next = stateCreatedByEnd
}

func stateCreatedByEnd(p *parser, line []byte) {
	file, lineNum, autogen, ok := parseFile(line)
	if !ok || len(autogen) > 0 {
		p.setCorrupt("failed looking for created by file", line)
		return
	}
	p.g.createdBy.file = strmap(files, file)
	p.g.createdBy.line = lineNum
	p.next = nil // we are done
}

func (p *parser) setCorrupt(why string, line []byte) {
	p.corrupt = true
	if p.corruptFatal {
		fmt.Printf("%s on line %q\n", why, line)
		os.Exit(1)
	}
}
